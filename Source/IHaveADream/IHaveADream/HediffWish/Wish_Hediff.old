using RimWorld;
using HarmonyLib;
using Verse;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace HDream
{
    public class Wish_Hediff : WishWithComp
    {

        public HediffWishDef Def => (HediffWishDef)def;

        public uint AmountNeeded => (uint)Def.amountNeeded;

        private int doAtTick = 0;
        public const int waitForTick = 200;

        protected int hediffCount = 0;

        protected List<HediffWishInfo> hediffsNeeded = new List<HediffWishInfo>();
        public List<HediffWishInfo> HediffsNeeded => hediffsNeeded;


        protected List<HediffDef> hediffToGetRid;
        public List<HediffDef> HediffToGetRid => hediffToGetRid;

        protected Dictionary<int, int> linkNeededToGetRid = new Dictionary<int, int>();

        protected bool isNeededLinkedToGetRid = false;
        public override void ExposeData()
        {
            base.ExposeData();
            Scribe_Values.Look(ref doAtTick, "lastTick", 0);
            Scribe_Values.Look(ref hediffCount, "hediffCount", 0);
            Scribe_Deep.Look(ref hediffsNeeded, "hediffsNeeded");
            Scribe_Collections.Look(ref hediffToGetRid, "hediffToGetRid");
            Scribe_Collections.Look(ref linkNeededToGetRid, "linkNeededToGetRid");
            Scribe_Values.Look(ref isNeededLinkedToGetRid, "isNeededLinkedToGetRid", false);
        }
        public override void PostMake()
        {
            base.PostMake();
            List<HediffWishInfo> hediffWishInfos = PrimeHediffInfo();

            if (hediffWishInfos.Count == 0 && hediffToGetRid.NullOrEmpty())
            {
                MakeFailed();
                return;
            }
            if (Def.wantSpecific)
            {
                if (def.tryPreventSimilare)
                {
                    List<HediffDef> similareHediff = new List<HediffDef>();
                    List<Wish> wishes = pawn.wishes().wishes;
                    for (int i = 0; i < wishes.Count; i++)
                    {
                        if (wishes[i].def == def)
                        {
                            if (hediffWishInfos.Where(info => info.def == (wishes[i] as Wish_Hediff).HediffsNeeded[0].def).Any())
                                    similareHediff.Add((wishes[i] as Wish_Hediff).HediffsNeeded[0].def);
                            HediffRidRemoveFromSpecificWish(wishes[i] as Wish_Hediff);
                        }
                    }
                    if (similareHediff.Count < hediffWishInfos.Count) for (int i = 0; i < similareHediff.Count; i++) hediffWishInfos.RemoveAll(info => info.def == similareHediff[i]);
                }
                if (hediffWishInfos.Count > 0)
                {
                    if (!hediffToGetRid.NullOrEmpty())
                    {
                        if (isNeededLinkedToGetRid)
                        {
                            float possibility = hediffWishInfos.Count + hediffToGetRid.Count - linkNeededToGetRid.Count;
                            possibility = Mathf.FloorToInt(Rand.Value * possibility);
                            int num;
                            if (possibility < hediffWishInfos.Count - linkNeededToGetRid.Count)
                            {
                                num = 0;
                                for (int j = 0; j < hediffWishInfos.Count; j++)
                                {
                                    if (linkNeededToGetRid.ContainsKey(j)) continue;
                                    if (possibility == num)
                                    {
                                        hediffsNeeded.Add(hediffWishInfos[j]);
                                        HediffRidNegate();
                                        linkNeededToGetRid.Clear();
                                        isNeededLinkedToGetRid = false;
                                        break;
                                    }
                                    else num++;
                                }
                            }
                            else if(possibility < hediffWishInfos.Count + hediffToGetRid.Count - (linkNeededToGetRid.Count * 2))
                            {
                                num = hediffWishInfos.Count - linkNeededToGetRid.Count;
                                for (int j = 0; j < hediffToGetRid.Count; j++)
                                {
                                    if (linkNeededToGetRid.ContainsValue(j)) continue;
                                    if (possibility == num)
                                    {
                                        HediffRidKeepOnly(j);
                                        hediffsNeeded = null;
                                        linkNeededToGetRid.Clear();
                                        isNeededLinkedToGetRid = false;
                                        break;
                                    }
                                    else num++;
                                }
                            }
                            else
                            {
                                num = hediffWishInfos.Count + hediffToGetRid.Count - (linkNeededToGetRid.Count * 2);
                                foreach ( var item in linkNeededToGetRid)
                                {
                                    if (possibility == num)
                                    {
                                        hediffsNeeded.Add(hediffWishInfos[item.Key]);
                                        HediffRidKeepOnly(linkNeededToGetRid[item.Value]);
                                        linkNeededToGetRid.Clear();
                                        linkNeededToGetRid.Add(0, 0);
                                        break;
                                    }
                                    else num++;
                                }
                            }
                        }
                        else if (Rand.Value < 0.5f)
                        {
                            hediffsNeeded.Add(hediffWishInfos[Mathf.FloorToInt(Rand.Value * hediffWishInfos.Count)]);
                            HediffRidNegate();
                        }
                        else
                        {
                            HediffRidKeepOnly(Mathf.FloorToInt(Rand.Value * hediffToGetRid.Count));
                            hediffsNeeded = null;
                        }
                    }
                    else hediffsNeeded.Add(hediffWishInfos[Mathf.FloorToInt(Rand.Value * hediffWishInfos.Count)]);
                }
                else HediffRidKeepOnly(Mathf.FloorToInt(Rand.Value * hediffToGetRid.Count));
            }
            else hediffsNeeded = hediffWishInfos;

            hediffCount = CountHediff();
        }
        protected virtual void HediffRidKeepOnly(int index)
        {
            HediffDef hed = hediffToGetRid[index];
            hediffToGetRid.Clear();
            hediffToGetRid.Add(hed);
        }
        protected virtual void HediffRidRemoveFromSpecificWish(Wish_Hediff wish)
        {
            hediffToGetRid.Remove(wish.HediffToGetRid[0]);
        }
        protected virtual void HediffRidNegate()
        {
            hediffToGetRid = null;
        }
        protected virtual List<HediffWishInfo> PrimeHediffInfo()
        {
            return new List<HediffWishInfo>(Def.CompleteInfos);
        }
        public override void Tick()
        {
            base.Tick();
            if (Find.TickManager.TicksGame < doAtTick) return;
            doAtTick = Find.TickManager.TicksGame + waitForTick;
            CheckHediff();
        }

        protected void CheckHediff()
        {
            int count = CountHediff();
            if (count >= AmountNeeded)
            {
                OnFulfill();
                return;
            }
            if(count != hediffCount)
            {
                ChangeProgress(count - hediffCount);
                hediffCount = count;
            }
        }
        protected int CountHediff()
        {
            int count = 0;
            List<Hediff> hediffs = pawn.health.hediffSet.hediffs;
            List<int> neededIndex = new List<int>();
            List<int> getRidIndex = new List<int>();

            if (hediffsNeeded != null)
            {
                for (int i = 0; i < hediffsNeeded.Count; i++)
                {
                    for (int j = 0; j < hediffs.Count; j++)
                    {
                        if (hediffs[j].def == hediffsNeeded[i].def
                            && hediffs[j].Severity >= hediffsNeeded[i].severityToReach
                            && hediffs[j].CurStageIndex >= hediffsNeeded[i].stageToReach)
                        {
                            if(isNeededLinkedToGetRid) neededIndex.Add(i);
                            count++;
                            if (!hediffsNeeded[i].countAllMatch) break;
                        }
                    }
                }
            }
            if (hediffToGetRid != null)
            {
                count += hediffToGetRid.Count;
                List<int> checker = new List<int>();
                for (int j = 0; j < hediffs.Count; j++)
                {
                    if (isNeededLinkedToGetRid) getRidIndex.Add(j);
                    for (int i = hediffToGetRid.Count - 1; i >= 0; i--)
                    {
                        if (checker.Contains(i)) continue;
                        if (MatchingGetRidAtIndex(i, hediffs[j]))
                        {
                            checker.Add(i);
                            count--;
                            if (isNeededLinkedToGetRid) getRidIndex.Remove(j);
                        };
                    }
                }
            }
            if (isNeededLinkedToGetRid) 
            {
                foreach (var item in linkNeededToGetRid)
                {
                    if (neededIndex.Contains(item.Key)) 
                    {
                        if (!getRidIndex.Contains(item.Value)) count--;
                    } 
                    else if(getRidIndex.Contains(item.Value)) count--;
                }
            }
                
            return count;
        }
        protected virtual bool MatchingGetRidAtIndex(int index, Hediff hediff)
        {
            return hediffToGetRid[index] == hediff.def;
        }
        public override string FormateText(string text)
        {
            text = text.Replace(Def.amount_Key, AmountNeeded.ToString());
            string listing = "";
            for (int i = 0; i < hediffsNeeded.Count; i++)
            {
                listing += hediffsNeeded[i].def.label;
                if (i != hediffsNeeded.Count - 1) listing += ", ";
            }
            text = text.Replace(Def.covetedObjects_Key, listing);
            return base.FormateText(text);
        }

        public override string DescriptionToFulfill
        {
            get
            {
                return base.DescriptionToFulfill + (AmountNeeded > 1 ? " (" + hediffCount.ToString() + "/" + AmountNeeded.ToString() + ")" : "");
                
            }
        }
    }
}
